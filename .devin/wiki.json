{
  "repo_notes": [
    {
      "content": "NEUROTOXIC: GRIND THE VOID v3.0 is a client-side single-page web game (React 19.2.4 + Vite 7.3.1) combining a roguelike tour manager with a 3-lane rhythm action game rendered with Pixi.js 8 at 60fps. No backend; all state persists to localStorage. The player manages a Death Grindcore band touring procedurally-generated German cities. The audio system has been modularized into src/utils/audio/ (6 modules: setup.js, playback.js, procedural.js, assets.js, state.js, constants.js) plus src/utils/AudioManager.js (singleton coordinator) and a thin facade in src/utils/audioEngine.js. Total audio subsystem is ~2,600 lines using Tone.js 15 for Web Audio synthesis/scheduling. The rhythm game hook has been decomposed into 5 sub-hooks under src/hooks/rhythmGame/ orchestrated by useRhythmGameLogic.js.",
      "author": "Developer"
    },
    {
      "content": "Prioritize inspection order: src/utils/audio/ directory (setup.js for Tone.js boot, playback.js for playback control, procedural.js for synth generation), src/utils/AudioManager.js (singleton lifecycle), src/context/GameState.jsx (GameStateProvider, useGameState), src/context/gameReducer.js (ActionTypes, gameReducer), src/hooks/rhythmGame/ directory (useRhythmGameLoop for timing, useRhythmGameScoring for hit judgment, useRhythmGameAudio for playback sync), src/hooks/useTravelLogic.js (travel mechanics), src/hooks/usePurchaseLogic.js (purchase mechanics), src/components/PixiStageController.js + src/components/stage/ managers, then src/ui and src/data.",
      "author": "Architecture"
    },
    {
      "content": "Cross-module relationships must be explicit: scenes dispatch via useGameState() helpers such as changeScene(); hooks call pure utilities like calculateGigFinancials(), calculateTravelExpenses(), checkEvent(), and calculateDailyUpdates(); data from src/data/events/, venues.js, songs.js, upgrades.js, and hqItems.js defines runtime content for UI and gameplay. The dependency direction is strictly scenes -> hooks/context -> utils/data; reverse imports from utility modules into scenes are prohibited. The rhythm game sub-hooks in src/hooks/rhythmGame/ compose together through useRhythmGameLogic.js which acts as an orchestration facade.",
      "author": "Architecture"
    },
    {
      "content": "Always include constraints and risks: React 19.2.4 + Vite 7.3.1 + Tailwind v4.1.18 are version-pinned — DO NOT upgrade. Tailwind v4 syntax rules from docs/TAILWIND_V4_PATTERNS.md require bg-(--void-black) not bg-[var(--void-black)]. CSS variable color policy enforced in src/index.css. State safety rules: player.money >= 0 and band.harmony > 0. AudioContext gesture constraints via ensureAudioContext(). localStorage tampering risk partially mitigated via safeStorageOperation (runtime storage exception handling) plus loadGame() state validation/clamping in src/context/GameState.jsx and schema checks in src/utils/saveValidator.js.",
      "author": "Quality"
    },
    {
      "content": "Deprioritize dist/, node_modules/, and generated files. If space is needed, consolidate low-priority implementation details into page_notes under parent architecture pages rather than creating more top-level pages.",
      "author": "Quality"
    },
    {
      "content": "Every src/ subdirectory has an AGENTS.md file (src/context/AGENTS.md, src/hooks/AGENTS.md, src/scenes/AGENTS.md, src/utils/AGENTS.md, src/components/AGENTS.md, src/data/AGENTS.md, src/ui/AGENTS.md) containing domain-specific coding guidance and constraints. The root AGENTS.md routes contributors to the correct nested file. Always consult the relevant AGENTS.md before modifying code in that directory. Additionally, docs/ARCHITECTURE.md and docs/STATE_TRANSITIONS.md provide system-level diagrams and state machine documentation respectively.",
      "author": "Architecture"
    },
    {
      "content": "Procedural asset generation (images) integrated via Pollinations.ai (imageGen.js) and social media simulation (socialEngine.js). Procedural map generation (mapGenerator.js) builds a graph of ~45 German venue nodes with travel connections, distance costs, and venue metadata that feeds the travel and event systems. The unlock/achievement system (unlockManager.js) tracks progression milestones. The tutorial system (TutorialManager.jsx) provides step-by-step onboarding tooltips for new players.",
      "author": "Developer"
    },
    {
      "content": "End-to-end tests in e2e/ use Playwright (configured via playwright.config.js) with 3 spec files: audio-output.spec.js (audio playback verification), game-flow.spec.js (full gameplay loop from menu through gig cycle), and helpers.js (shared test utilities). The .claude/skills/ directory contains 28 custom Claude Code skills providing specialized AI-assisted workflows for common development tasks (audio debugging, CI hardening, game balancing, performance budgeting, Pixi memory leak detection, refactoring safety, Tailwind v4 enforcement, etc.). These skills are tuned to the codebase's architecture patterns and should be referenced when performing domain-specific work.",
      "author": "Quality"
    }
  ],
  "pages": [
    {
      "title": "Overview",
      "purpose": "Build the canonical landing page for the documentation set, linking docs/ARCHITECTURE.md, docs/STATE_TRANSITIONS.md, README.md setup commands, src/context/GameState.jsx, src/context/gameReducer.js, src/utils/AudioManager.js, src/utils/audio/ modules, src/hooks/useRhythmGameLogic.js, src/scenes/Gig.jsx, and src/components/PixiStageController.js so contributors can jump from concept to implementation in one hop.",
      "page_notes": [
        {
          "content": "Explain the full gameplay loop as implemented by src/scenes/Overworld.jsx -> src/scenes/PreGig.jsx -> src/scenes/Gig.jsx -> src/scenes/PostGig.jsx with scene changes initiated through GameState actions. The game cycles through strategic overworld decisions (travel, purchases, event responses), pre-gig preparation (setlist selection, gear checks), rhythm performance execution (3-lane note-highway gameplay), and post-gig results calculation (money/fame/harmony updates, event outcomes). Each scene is a React component that consumes useGameState() context and dispatches typed actions through ActionTypes defined in gameReducer.js.",
          "author": "Architecture"
        },
        {
          "content": "Include a short map from high-level sections to files so first-time contributors know where to start reading code: State Management (src/context/), Game Logic Hooks (src/hooks/), Scenes/Routing (src/scenes/, src/App.jsx), Pure Utilities (src/utils/), Rendering (src/components/), UI Components (src/ui/), Static Data (src/data/), Tests (tests/, e2e/), Documentation (docs/), Configuration (root config files). Emphasize that AGENTS.md files in each src/ subdirectory contain authoritative domain-specific rules.",
          "author": "Architecture"
        },
        {
          "content": "Call out AGENTS.md precedence rules so contributors check nested guidance before editing scoped modules. The root AGENTS.md acts as a router directing to subdirectory-specific files. Each subdirectory AGENTS.md defines constraints, common pitfalls, testing expectations, and architectural boundaries for that module. When making changes, always read the relevant AGENTS.md first to understand local invariants and integration contracts.",
          "author": "Architecture"
        },
        {
          "content": "Define documentation boundaries: frontend-only SPA (no backend/API), ownership of scenes/hooks/utils/ui modules, non-goals (dist/, node_modules/). Persistence via saveGame()/loadGame() does not include encryption; documentation should emphasize why systems exist and how they interact, not only API signatures. The game runs entirely client-side using localStorage for persistence, Web Audio API via Tone.js for sound, and Pixi.js for canvas rendering. No server endpoints, no database, no multiplayer networking.",
          "author": "Architecture"
        }
      ]
    },
    {
      "title": "Game Concept",
      "purpose": "Document the player loop with file-level anchors: travel decisions in src/scenes/Overworld.jsx and src/hooks/useTravelLogic.js, gig preparation in src/scenes/PreGig.jsx, rhythm execution in src/scenes/Gig.jsx via useRhythmGameLogic() and its 5 sub-hooks in src/hooks/rhythmGame/, and outcome application in src/scenes/PostGig.jsx using calculateGigFinancials(), resolvePost(), and reducer updates for money/fuel/harmony/followers.",
      "parent": "Overview",
      "page_notes": [
        {
          "content": "Describe strategic pressure around money, fuel, and harmony and where these values are consumed by utility functions in src/utils/economyEngine.js and src/utils/simulationUtils.js. Money is spent on fuel, upgrades, and repairs; fuel enables travel between cities; harmony represents band cohesion and affects gig performance. These three resources create strategic tension: players must balance immediate spending (fuel for travel, upgrades for performance) against long-term sustainability (maintaining harmony, building fame for better venues). The economy functions enforce non-negative money constraints and harmony thresholds that trigger game-over conditions.",
          "author": "Gameplay"
        },
        {
          "content": "Include one worked example tour day showing travel cost, event trigger, gig result, and post-gig stat changes. Example: Day 5, located in Stendal (€500, 40% fuel), travel to Berlin (120km, €40 fuel cost, €0 toll). During travel, checkEvent() triggers 'Breakdown' event (50% chance on low harmony). Player chooses 'Quick Fix' option (€150, -1 day delay). Arrive Berlin, select gig at SO36 (capacity 500, base pay €300). Pre-gig: select setlist, check gear. Gig: rhythm performance yields 85% accuracy, 120 combo max, crowd hype 75%. Post-gig: calculateGigFinancials() returns €380 payout, +50 followers, +5 fame, -10 harmony. Net result: €190 profit after travel/event costs, positioned for next venue unlock.",
          "author": "Gameplay"
        },
        {
          "content": "The game's procedural generation systems work together to create emergent narratives: mapGenerator.js builds the venue network, eventEngine.js triggers random encounters based on game state, socialEngine.js simulates fan reactions, and imageGen.js generates visual assets on-demand. These systems combine with the player's strategic choices (which city to visit, which gig to accept, how to respond to events) and tactical performance (rhythm game execution) to create unique playthroughs where no two tours are identical.",
          "author": "Gameplay"
        }
      ]
    },
    {
      "title": "Scene Flow & Game Loop",
      "purpose": "Describe exact scene transition mechanics implemented through createChangeSceneAction() in src/context/actionCreators.js, changeScene() from useGameState() in src/context/GameState.jsx, ActionTypes.CHANGE_SCENE handling in src/context/gameReducer.js, and the scene router in src/App.jsx for INTRO (src/scenes/IntroVideo.jsx), MENU (src/scenes/MainMenu.jsx), SETTINGS, CREDITS, OVERWORLD, PREGIG, GIG, POSTGIG, and GAMEOVER.",
      "parent": "Overview",
      "page_notes": [
        {
          "content": "Reference docs/STATE_TRANSITIONS.md for the canonical state-machine narrative and note differences if implementation diverges. The state machine defines legal transitions between scenes, entry/exit conditions, and data dependencies. Any discrepancies between the documented state machine and the actual gameReducer.js implementation should be flagged as technical debt. The scene flow is deterministic except for event-triggered interruptions (which insert modal overlays but do not change the underlying scene state).",
          "author": "Architecture"
        },
        {
          "content": "List transition triggers: travel completion (useTravelLogic tick progression dispatches CHANGE_SCENE to PREGIG), gig start (PreGig.jsx user action dispatches CHANGE_SCENE to GIG), gig end (useRhythmGameLogic completion callback dispatches CHANGE_SCENE to POSTGIG), event modal resolution (EventModal.jsx choice selection may trigger scene changes via effect outcomes), and game-over transitions. Money is clamped at reducer and scene boundaries with Math.max(0, newMoney), so money < 0 is not a reachable trigger in normal state updates. The implemented GAMEOVER triggers are stranded softlock in useTravelLogic when the player cannot reach any neighbor and cannot afford required refuel cost (using clamped money/fuel), explicit event outcomes that set delta.flags.gameOver, and post-gig bankruptcy when net income is negative and the clamped post-update balance is money === 0. Harmony is also clamped in reducer paths, but defensive harmony <= 0 guards still exist in gig initialization for malformed/external state. Document failure transitions into GAMEOVER and recovery/return paths back to MENU (restart action from GameOver; no mid-game reload back into the failed run).",
          "author": "Architecture"
        },
        {
          "content": "Document src/scenes/MainMenu.jsx as boot entry: user-gesture audio bootstrap via ensureAudioContext() and AudioManager.startAmbient() (required for browser autoplay policy compliance), continue-game hydration via loadGame() from GameState.jsx (reads localStorage through safeStorageOperation, validates and repairs shape via saveValidator.js before dispatching LOAD_GAME), and startup routing that reflects implementation behavior (new game calls resetState(), then changeScene('OVERWORLD'); continue path calls loadGame() then changeScene('OVERWORLD') on success). Note that MainMenu does not dispatch INITIALIZE_MAP/START_TOUR/RESUME_TOUR actions and does not render a 'Click to Start' overlay; instead it surfaces error text when audio unlock or loading fails to avoid silent startup failures.",
          "author": "Architecture"
        }
      ]
    },
    {
      "title": "Tech Stack",
      "purpose": "Record dependency roles with explicit package.json anchors: react/react-dom 19.2.4 for UI, vite 7.3.1 for dev/build, pixi.js 8.16.0 for canvas rendering, tone 15.1.22 for audio graph/scheduling, tailwindcss 4.1.18 for utility styling, framer-motion 12.34.0 for animated UI transitions, and @tonejs/midi 2.0.28 for MIDI file parsing. Explain why React/Vite/Tailwind pinning is mandatory for compatibility and reference .nvmrc for Node.js 22.3.0+ runtime requirement.",
      "parent": "Overview",
      "page_notes": [
        {
          "content": "State non-negotiable pinning: do not upgrade React (stay 19.2.4), Vite (stay 7.3.1), or Tailwind (stay 4.1.18) without dedicated migration documentation updates. React 19 introduced breaking changes in concurrent rendering and hydration; Vite 7 changed HMR behavior; Tailwind v4 completely rewrote CSS variable handling. These versions have been tested together and any upgrade requires regression testing across all 49 unit tests, e2e flows, and production build verification. The pinning is enforced in package.json via exact version specifiers (no ^ or ~ prefixes).",
          "author": "Quality"
        },
        {
          "content": "Mention Node.js 22.3+ runtime requirement used by test and build workflows and where it is declared in .nvmrc. The project uses ES modules ('type': 'module' in package.json) with ES2021+ syntax including top-level await, optional chaining, nullish coalescing, and private class fields. Node 22+ is required for native test runner support (node:test module used in tests/) and ES module resolution compatibility. Developers should run 'nvm use' to align with .nvmrc before npm install.",
          "author": "Quality"
        },
        {
          "content": "Additional key dependencies: prop-types for runtime type checking in development, eslint + prettier for code quality, playwright for e2e testing, tsx for running tests with TypeScript-style imports, jscpd for code duplication detection. The build outputs to dist/ as static assets deployable to any HTTP server (GitHub Pages, Netlify, Vercel) with no server-side rendering or API requirements. Total production bundle size target: <300kB gzipped for main chunk.",
          "author": "Quality"
        }
      ]
    },
    {
      "title": "Project Structure",
      "purpose": "Map repository structure to runtime behavior with concrete examples: src/main.jsx app mount, src/context/ reducers/actions, src/hooks/ orchestration hooks (including src/hooks/rhythmGame/ sub-hooks), src/scenes/ route-level containers, src/utils/ pure engines and audio services (including src/utils/audio/ modularized subsystem), src/components/ Pixi controllers/overlays (including src/components/stage/ rendering managers), src/ui/ reusable design-system widgets, src/data/ static game databases, src/assets/ MIDI/OGG audio files, tests/ node:test suites (49 test files), e2e/ Playwright integration tests, and docs/ architecture references. Highlight the AGENTS.md file in each src/ subdirectory as the authoritative guide for that module.",
      "parent": "Overview",
      "page_notes": [
        {
          "content": "Point to tests/ as the verification layer and map each major utility module to its corresponding test file when available. Test coverage includes: economyEngine.test.js, eventEngine.test.js, gameReducer.test.js, rhythmGameLogic.test.js, audioManager.test.js, mapGenerator.test.js, and 40+ additional unit tests. The tests/ directory mirrors src/ structure for discoverability. Integration tests in tests/goldenPath.test.js cover the full gameplay loop. Performance benchmarks in tests/performance/ verify optimization targets (60 FPS Pixi rendering, <100ms audio latency).",
          "author": "Quality"
        },
        {
          "content": "Include .claude/skills/ (28 custom Claude Code skills) and .github/workflows/ (deploy.yml, super-linter.yml, lint-fix-preview.yml) as developer tooling surfaces. The .claude/skills/ directory contains specialized AI prompts for common development tasks (code generation, refactoring, documentation updates) tuned to the codebase's architecture patterns. The GitHub workflows provide CI automation: deploy.yml builds and publishes to GitHub Pages on main branch pushes, super-linter.yml runs ESLint on PRs with inline comments, lint-fix-preview.yml auto-fixes formatting issues and creates preview comments.",
          "author": "Quality"
        },
        {
          "content": "Configuration files at repository root: vite.config.js (build setup, dev server), eslint.config.js (flat config with react/hooks rules), tailwind.config.js (v4 theme with CSS variables), postcss.config.js (Tailwind integration), playwright.config.js (e2e test harness), .prettierrc (code formatting), biome.json (alternative linter config), jsconfig.json (IDE support), .nvmrc (Node version), .jscpd.json (duplication detection thresholds). Each config file is documented inline with comments explaining non-obvious settings and migration notes for version-specific behavior.",
          "author": "Quality"
        }
      ]
    },
    {
      "title": "System Architecture",
      "purpose": "Explain layered flow end-to-end: GameStateProvider/useReducer as state core (src/context/*), hooks as orchestration layer (useTravelLogic, usePurchaseLogic, useRhythmGameLogic with 5 decomposed sub-hooks), utility engines as deterministic calculators (economyEngine, eventEngine, simulationUtils), audio services as side-effect boundary (AudioManager singleton + src/utils/audio/ modules), and rendering split between React scene composition and PixiStageController + stage managers (NoteManager, LaneManager, CrowdManager, EffectManager) for frame updates.",
      "parent": "Overview",
      "page_notes": [
        {
          "content": "Explicitly separate side-effect boundaries (audio via AudioManager/audio/, storage via safeStorageOperation, timers) from pure calculation modules to guide maintainable changes. Pure functions in src/utils/ are deterministic, testable without mocks, and have no external dependencies beyond input parameters. Side-effect modules are isolated to: audio/ (Web Audio API via Tone.js), errorHandler.js (localStorage + toast dispatch), logger.js (console + in-memory log buffer), and imageGen.js (fetch to Pollinations.ai). This separation enables parallel development, focused testing, and safe refactoring.",
          "author": "Architecture"
        },
        {
          "content": "Document how action creators in src/context/actionCreators.js are preferred over ad-hoc dispatch object literals. Include the dependency-direction rule: scenes -> hooks/context -> utils/data; avoid reverse imports. Action creators provide type safety (ActionTypes constants), encapsulate action payload shape requirements, and enable IDE autocomplete for dispatch calls. The dependency hierarchy prevents circular imports and ensures utilities remain reusable: scenes can import hooks, hooks can import context, context can import utils, but reverse imports are prohibited (enforced via ESLint import rules).",
          "author": "Architecture"
        },
        {
          "content": "The architecture follows a unidirectional data flow pattern inspired by Redux/Flux: user interactions in scenes trigger action dispatches, actions flow through the reducer to update centralized state, state changes propagate via React context to re-render dependent components. Hooks orchestrate multi-step interactions (e.g., useTravelLogic coordinates tick progression, event checks, fuel consumption, scene transitions) while keeping individual utility functions focused and testable. The PixiStageController bridges the React world (declarative state updates) with the Pixi world (imperative frame-by-frame rendering) via refs and ticker callbacks.",
          "author": "Architecture"
        }
      ]
    },
    {
      "title": "Core Subsystems Overview",
      "purpose": "Provide a subsystem dependency map that names primary files and key functions: AudioManager (src/utils/AudioManager.js) + modularized audio modules (src/utils/audio/: setup.js, playback.js, procedural.js, assets.js) for playback lifecycle; GameStateProvider + gameReducer for state transitions; useRhythmGameLogic orchestrating 5 sub-hooks for rhythm timing; PixiStageController + 4 stage managers for render/update cycle; calculateGigFinancials()/calculateTravelExpenses() economy pipeline (economyEngine.js); mapGenerator for travel topology; checkEvent()/resolveChoice() event resolution (eventEngine.js); and socialEngine.js, imageGen.js, hecklerLogic.js for procedural content generation.",
      "parent": "Overview",
      "page_notes": [
        {
          "content": "Keep this page architecture-focused; push implementation details into child pages. Tag each subsystem with maintenance risk level and quick rationale: Audio System (Medium — Tone.js lifecycle complexity, browser AudioContext constraints), State Management (Low — standard React patterns, well-tested), Rhythm Game (High — frame-perfect timing, audio-visual sync, performance-critical), Pixi Rendering (Medium — cleanup discipline required, ticker leak risk), Economy Engine (Low — pure functions, deterministic math), Event Engine (Low — data-driven, schema-validated), Map Generation (Low — one-time setup, cached results). Onboarding contributors should prioritize Low/Medium risk areas before tackling High risk subsystems.",
          "author": "Architecture"
        },
        {
          "content": "Document cross-subsystem integration points: rhythm game consumes audio playback state and triggers sound effects via AudioManager; economy calculations feed into post-gig state updates via reducer actions; event outcomes apply delta effects through gameStateUtils.js; map topology constrains travel logic in useTravelLogic; social engine reactions are displayed via ChatterOverlay component. These integration contracts are the most fragile points during refactoring — changes to one subsystem's output shape require coordinated updates to consumers.",
          "author": "Architecture"
        }
      ]
    },
    {
      "title": "Audio System Architecture",
      "purpose": "Document the modularized audio subsystem (~2,600 lines total) spanning src/utils/AudioManager.js (singleton coordinator), src/utils/audioEngine.js (facade re-exporting key functions), and 6 specialized modules in src/utils/audio/: setup.js (Tone.js boot via setupAudio()/ensureAudioContext, Tone.Context timing params, instrument chains for guitar/bass/drums/SFX/clean-MIDI buses, compressor/limiter/musicGain routing), playback.js (loadAudioBuffer, playRandomAmbientOgg/playRandomAmbientMidi, startGigPlayback, stopGigPlayback/stopAudioInternal, disposal guarantees), procedural.js (procedural synth generation for backing tracks and SFX), assets.js (MIDI/audio asset loading), state.js (audio state tracking), constants.js (shared audio config constants).",
      "parent": "Core Subsystems Overview",
      "page_notes": [
        {
          "content": "Document four playback fallback modes (OGG -> MIDI -> note data -> procedural) and when each path is chosen. Call out disposal guarantees and known cleanup caveats around layered instrument nodes and exception safety during teardown. Primary path: load pre-recorded OGG from src/assets/ (fastest, best quality). Fallback 1: parse MIDI file and play via Tone.js synths (good quality, larger files). Fallback 2: use chart note data to generate backing track procedurally (acceptable quality, no files). Fallback 3: silent mode with visual-only rhythm game (degraded experience, used when audio initialization fails). Cleanup requires manual disposal of Tone.Transport events, synth nodes, and buffer references to prevent memory leaks.",
          "author": "Architecture"
        },
        {
          "content": "Helper utilities audioContextState.js, audioSelectionUtils.js, audioTimingUtils.js, and audioPlaybackUtils.js encapsulate low-level logic; midiTrackUtils.js handles MIDI file parsing and track extraction. Document the AudioManager singleton lifecycle: creation (on app mount), context resume on user gesture (via ensureAudioContext() in MainMenu.jsx), playback start/stop (via startGigPlayback()/stopGigPlayback() called from useRhythmGameAudio hook), and dispose (on app unmount via cleanup effect). The singleton pattern prevents multiple AudioContext instances (browser limit) and centralizes audio routing.",
          "author": "Architecture"
        },
        {
          "content": "Audio mixer architecture uses separate buses for instrument groups (guitar, bass, drums, SFX, vocals/MIDI) feeding into master compressor and limiter chains. Gain staging: individual instruments at -6dB, bus compressors with 4:1 ratio, master limiter at -0.1dB ceiling. Volume controls in settings affect musicGain node (pre-master). The mixer topology is initialized once in setup.js and reused across gigs; only source nodes (Players, Synths) are created/destroyed per-song. This architecture enables dynamic mixing (boost drums during fills, duck rhythm during vocals) without rebuilding the entire audio graph.",
          "author": "Architecture"
        }
      ]
    },
    {
      "title": "Rhythm Game Logic",
      "purpose": "Document the decomposed rhythm game hook system: src/hooks/useRhythmGameLogic.js (orchestrator) composing 5 specialized sub-hooks in src/hooks/rhythmGame/: useRhythmGameState.js (game state tracking, refs for frame-loop data), useRhythmGameInput.js (keyboard arrow key / A-S-D and touch input handling), useRhythmGameAudio.js (audio playback integration, gig clock sync), useRhythmGameLoop.js (ticker-driven game loop, note advancement, timing), useRhythmGameScoring.js (hit-window judgment, combo math, hype calculation, miss/penalty handling). Song data sourced from src/assets/rhythm_songs.json, note spawning from src/utils/rhythmUtils.js.",
      "parent": "Core Subsystems Overview",
      "page_notes": [
        {
          "content": "Explain timing sources (AudioContext.currentTime, Tone.now(), or game clock refs) and how drift is mitigated between audio and visual lanes. Specify how hit-judgment windows scale (or do not scale) with difficulty and where those constants are defined in rhythmUtils.js. The game uses AudioContext.currentTime as the authoritative clock for synchronization. Visual note positions are calculated from currentTime + spawn lead-in time. Hit windows are fixed (Perfect: ±50ms, Good: ±100ms, OK: ±150ms) regardless of difficulty; difficulty affects note density and pattern complexity instead. Drift mitigation: pre-calculate all note timestamps on song start, use RAF timestamps only for interpolation, re-sync every beat via audio playback callbacks.",
          "author": "Architecture"
        },
        {
          "content": "Include where gameplay output is written back to state for post-gig calculations via gigStats.js (35 lines). Heckler mechanics (projectile spawning) are handled by src/utils/hecklerLogic.js (101 lines); timing sync uses audioTimingUtils.js. The scoring hook accumulates hits/misses/perfects, calculates combo multipliers (1x at combo 0, up to 4x at combo 100+), and tracks crowd hype (increases on hits, decreases on misses, affects visual crowd reaction via CrowdManager.js). Final stats (accuracy %, max combo, total score, crowd hype %) are packaged into lastGigStats state slice via SET_GIG_RESULTS action dispatched on gig completion.",
          "author": "Architecture"
        },
        {
          "content": "Input handling supports both keyboard (arrow keys for lanes 1-3, A/S/D alternative layout) and touch (lane detection via x-coordinate of touch event, hit detection on touchstart). The input hook normalizes both input sources into a unified lane index (0, 1, 2) and timestamp. This abstraction allows the scoring hook to be input-agnostic. Touch calibration accounts for lane center positions in PixiStageController coordinate space. Future enhancement: gamepad support would add a third input source to the same normalization pipeline.",
          "author": "Architecture"
        }
      ]
    },
    {
      "title": "Pixi Rendering Pipeline",
      "purpose": "Describe rendering internals across src/components/PixiStageController.js, src/components/PixiStage.jsx (React canvas wrapper), and 4 stage managers in src/components/stage/: NoteManager.js (falling note sprite lifecycle, spawn/recycle/destroy), LaneManager.js (lane rendering, hit zones, visual feedback), CrowdManager.js (crowd visualization reacting to performance), EffectManager.js (hit/miss visual effects, particles). Document Pixi.js 8 Application lifecycle, ticker/frame callbacks, world-to-screen coordinate transforms, HUD overlay interoperability via src/components/GigHUD.jsx, and unmount cleanup (destroy textures, remove listeners, stop ticker).",
      "parent": "Core Subsystems Overview",
      "page_notes": [
        {
          "content": "Document cleanup expectations on scene unmount to prevent ticker leaks, retained textures, and stale refs. Follow the isMountedRef + app.destroy(true, { children: true, texture: true }) pattern. Reference pixiStageUtils.js for shared rendering helpers. Critical cleanup checklist: stop ticker, remove ticker callbacks, destroy all sprites (note sprites, lane graphics, effect sprites), clear sprite pools, nullify refs (appRef.current = null), dispose textures from cache. Common leak sources: forgotten ticker.add() without corresponding ticker.remove(), sprite pools not cleared, event listeners on stage/renderer not removed. The isMountedRef guard prevents post-unmount state updates from queued ticker callbacks.",
          "author": "Architecture"
        },
        {
          "content": "Describe z-order/layer strategy for lanes, notes, hit line, and transient feedback effects across the 4 stage managers. Document how NoteManager coordinates with useRhythmGameLoop for note positioning and with useRhythmGameScoring for hit feedback. Z-order from back to front: background gradient (z=0), lane backgrounds (z=10), crowd sprites (z=20), falling notes (z=30), hit line (z=40), hit feedback effects (z=50), HUD overlay (z=100, React layer). NoteManager receives note spawn commands from useRhythmGameLoop via props, updates note y-positions each frame based on elapsed time, and emits hit/miss events to useRhythmGameScoring when notes cross the hit line threshold. Visual feedback (particle bursts, color flashes) is rendered by EffectManager in response to scoring events.",
          "author": "Architecture"
        },
        {
          "content": "Performance optimizations in Pixi rendering: sprite pooling (pre-allocate 100 note sprites, recycle instead of create/destroy), texture atlas (combine note graphics into single texture to reduce draw calls), culling (skip rendering notes outside viewport), requestAnimationFrame throttling (lock to 60 FPS), batch rendering (group sprites by texture/blend mode). Benchmark target: maintain 60 FPS with 50+ active notes, 20+ particle effects, and crowd animations. Performance regression tests in tests/performance/pixiStage.bench.js verify rendering performance stays within budget. Profile using Chrome DevTools Performance tab to identify bottlenecks.",
          "author": "Architecture"
        }
      ]
    },
    {
      "title": "State Management & Context System",
      "purpose": "Document full state architecture combining src/context/GameState.jsx and src/context/gameReducer.js: ActionTypes taxonomy (30+ action types organized by domain: SCENE, PLAYER, BAND, SOCIAL, GIG, MAP, TOAST, EVENT), reducer branches for player/band/social/gig/map/toast/event slices, action creator contracts from src/context/actionCreators.js, enforcement points for invariants player.money >= 0 and band.harmony > 0 during state updates, and initialState.js defaults (money: 500, day: 1, location: Stendal, 3 band members, harmony: 80). Also cover GameStateProvider and useGameState() API: exposed state slices, dispatch helpers (changeScene, triggerEvent, addToast, updatePlayer, updateBand), memoization boundaries, and consumer usage patterns.",
      "parent": "Core Subsystems Overview",
      "page_notes": [
        {
          "content": "Include invariants for money and harmony and where guards are enforced before/after updates. List reducer actions that can affect economy stats to simplify auditing for money/harmony invariant safety. Money invariant (>= 0): enforced in UPDATE_PLAYER, TRAVEL_TICK, PURCHASE_ITEM, RESOLVE_EVENT actions via Math.max(0, newMoney) clamping. Harmony invariant (> 0 for playable): enforced in UPDATE_BAND, DAILY_UPDATE, GIG_END actions; harmony <= 0 triggers GAME_OVER transition. Actions affecting money: TRAVEL_TICK (-fuel cost), PURCHASE_ITEM (-item cost), GIG_END (+payout), RESOLVE_EVENT (±effect delta), DAILY_UPDATE (-living expenses). Actions affecting harmony: GIG_END (±performance modifier), BAND_CONFLICT (-event penalty), REST (+recovery), RESOLVE_EVENT (±effect delta).",
          "author": "Architecture"
        },
        {
          "content": "Clarify which parts of state are persisted versus runtime-only transient fields. Document expected consumer pattern in scenes/hooks to avoid direct mutation and stale closures. Persisted fields (saved to localStorage via saveGame()): player (money, day, location, inventory, tutorialStep), band (members, harmony, fame, followers), social (recentPosts, platformStats), map (venueGraph, unlockedVenues), activeStoryFlags. Transient fields (not persisted): currentGig (cleared on load), lastGigStats (recalculated), toasts (UI only), activeEvent (reset on scene change), gigModifiers (temporary buffs). Consumer pattern: destructure needed slices from useGameState() at component top level, call dispatch helpers for updates, never mutate state directly, use useCallback for event handlers to prevent stale closures.",
          "author": "Architecture"
        },
        {
          "content": "Document recommended selector/memo usage patterns to minimize unnecessary rerenders in scene components. Use React.memo() for leaf components that only depend on specific state slices (e.g., StatBox displaying player.money). Use useMemo() to derive computed values (e.g., affordability checks, filtered lists) from state slices. Split context into state and dispatch contexts (already implemented: GameStateContext provides state, dispatch is stable ref). Avoid selecting entire state object when only subset is needed — use const { player, band } = useGameState() not const state = useGameState(). Profile with React DevTools Profiler to identify render hotspots.",
          "author": "Architecture"
        }
      ]
    },
    {
      "title": "GameState Context",
      "purpose": "Detail GameStateProvider and useGameState() API surface: exposed state slices (player, band, social, settings, gameMap, currentGig, setlist, lastGigStats, activeEvent, toasts, activeStoryFlags, eventCooldowns, gigModifiers), dispatch helpers (changeScene, triggerEvent, addToast, setGigModifiers, updatePlayer, updateBand), memoization boundaries, and consumer usage patterns in scenes/hooks. Reference where provider wires persistence load/save hooks and how transient runtime fields are excluded from serialized payloads.",
      "parent": "State Management & Context System",
      "page_notes": [
        {
          "content": "Document the full useGameState() return shape with each exposed property and dispatch helper, including type signatures from JSDoc annotations. Group the API into read-only state slices (player, band, social, settings, gameMap, currentGig, setlist, lastGigStats, activeEvent, toasts, activeStoryFlags, eventCooldowns, gigModifiers) and mutation helpers (changeScene, triggerEvent, addToast, setGigModifiers, updatePlayer, updateBand, advanceDay, applyEventDelta). For each dispatch helper, specify which ActionType it dispatches, required parameters, and what reducer branch handles it.",
          "author": "Architecture"
        },
        {
          "content": "Document GameStateProvider initialization sequence: on mount, provider creates reducer with initialState, then checks localStorage for saved game via safeStorageOperation. If save exists, loadGame() runs saveValidator.js schema checks, repairs missing fields with defaults from initialState.js, clamps out-of-range values (money >= 0, harmony 0-100, day >= 1), and dispatches LOAD_GAME action. If save is corrupt or missing, initial state is used directly. The provider also registers beforeunload listener to auto-save on tab close. Detail the memoization boundary: state object reference changes on every dispatch, but dispatch function is stable (React guarantee), so components depending only on dispatch do not re-render.",
          "author": "Architecture"
        }
      ]
    },
    {
      "title": "Persistence & Save Data",
      "purpose": "Document persistence flow via saveGame()/loadGame() in src/context/GameState.jsx, safeStorageOperation in src/utils/errorHandler.js, and save schema validation in src/utils/saveValidator.js: safeStorageOperation wrappers, schema/version handling, reducer load actions, fallback behavior on parse failures, and guardrails against malformed/tampered localStorage data before applying values to player economy or band condition.",
      "parent": "State Management & Context System",
      "page_notes": [
        {
          "content": "Highlight tampering risk, schema drift concerns, and recommended validation checks before applying persisted values. Add migration guidance for future save schema versions, including defaulting rules for newly introduced fields.",
          "author": "Quality"
        },
        {
          "content": "Document the saveValidator.js validation pipeline stages: (1) JSON parse safety via try/catch, (2) top-level shape check ensuring required keys exist (player, band, social, settings, gameMap), (3) per-field type validation and range clamping (money >= 0, harmony 0-100, day >= 1, fuel 0-100), (4) array integrity for band.members and inventory lists, (5) default backfill for fields added in newer versions (merge with initialState.js defaults). Explain that validation is non-destructive — it repairs and returns a valid state rather than rejecting the save entirely. Document how safeStorageOperation in errorHandler.js wraps all localStorage calls with try/catch to handle quota exceeded, permission denied, and private browsing restrictions.",
          "author": "Architecture"
        }
      ]
    },
    {
      "title": "Economy & Resources",
      "purpose": "Explain lifecycle of money/fuel/harmony/fame/followers across travel and gigs, linking src/utils/economyEngine.js (430 lines), src/utils/simulationUtils.js (230 lines), src/scenes/Overworld.jsx, and src/scenes/PostGig.jsx. Include where daily costs, refuel spend, gig payouts, and modifiers are calculated and how results dispatch through reducer updates.",
      "parent": "Core Subsystems Overview",
      "page_notes": [
        {
          "content": "Provide a summary table of all resource producers/consumers (travel, refuel, events, gig payouts, purchases). Document src/utils/economyEngine.js contract-level functions: calculateGigFinancials(), calculateTravelExpenses(), and helpers with required input shapes, output breakdown fields, rounding/normalization rules, and call sites enforcing no-negative-money constraints.",
          "author": "Architecture"
        },
        {
          "content": "Include edge-case behavior for low-resource states and examples of expected output for typical gig, low attendance gig, and high bonus gig scenarios.",
          "author": "Gameplay"
        }
      ]
    },
    {
      "title": "Travel & Map System",
      "purpose": "Document route traversal and map generation: src/hooks/useTravelLogic.js (565 lines — graph traversal, path progression ticks, day advancement, fuel burn, travel completion events, integration with calculateDailyUpdates and random encounter checks from eventEngine) and src/utils/mapGenerator.js (279 lines — procedural Germany map building ~45 venue nodes from src/data/venues.js with geographic coordinates, travel connections with distance-based fuel costs, region clustering). Document how the generated graph is stored in gameMap state slice and consumed by src/scenes/Overworld.jsx, src/components/MapNode.jsx, and src/components/MapConnection.jsx for rendering.",
      "parent": "Core Subsystems Overview",
      "page_notes": [
        {
          "content": "Explain how venue data from src/data/venues.js feeds into node creation: required fields (id, name, city, region, type, capacity, basePay, difficulty, prestige) versus optional (requirements). Document connection generation strategy ensuring full graph connectivity.",
          "author": "Architecture"
        },
        {
          "content": "Document how map node metadata (venue capacity, city size, distance) influences event probability or travel outcomes. Point to functions that compute daily updates and explain when travel tick side effects are dispatched.",
          "author": "Architecture"
        }
      ]
    },
    {
      "title": "Event Engine & Effect Semantics",
      "purpose": "Deep dive src/utils/eventEngine.js (295 lines) behavior around checkEvent(), resolveChoice(), processOptions(), and effect application, with schema sourced from src/data/events/index.js and category files (band.js, financial.js, gig.js, special.js, transport.js). Specify alias mappings, accumulation vs overwrite semantics for composite effects, and deterministic testing patterns from tests/eventEngine.test.js using mocked randomness. State mutations are centralized in src/utils/gameStateUtils.js (154 lines, applyEventDelta); event flow is wrapped by src/utils/eventResolver.js (24 lines).",
      "parent": "Core Subsystems Overview",
      "page_notes": [
        {
          "content": "Call out alias mapping behavior (hype/crowd_energy -> fame with accumulation, mood/stamina use direct assignment) and whether repeated effect keys accumulate or overwrite during composite event resolution. Include guardrails for adding new effect keys.",
          "author": "Architecture"
        },
        {
          "content": "Include deterministic testing strategy using mocked random values from tests/eventEngine.test.js. Document event schema: id, title, description, trigger (travel|pregig|postgig|random), chance, condition function, choices array with text/cost/outcome/skillCheck/nextEvent/setFlag, cooldown, and tags.",
          "author": "Quality"
        }
      ]
    },
    {
      "title": "Purchases & Upgrades",
      "purpose": "Document upgrade progression architecture across src/hooks/usePurchaseLogic.js (415 lines), src/data/upgrades.js, src/data/hqItems.js, and UI consumers src/ui/BandHQ.jsx (band management, crew roster, member stats, HQ item purchases) and upgrade menus: category models (VAN|GEAR|MERCH|PROMO), unlock requirements, ownership state, affordability gates, side effects on stats/resources, and reducer actions used to persist purchases.",
      "parent": "Overview",
      "page_notes": [
        {
          "content": "Document usePurchaseLogic.js function-level contracts: canAfford(), isItemOwned(), isItemDisabled(), purchase handlers, emitted toast/error states, and safe handling of race conditions or stale state snapshots during rapid purchases.",
          "author": "Architecture"
        },
        {
          "content": "Add note on balancing philosophy: upgrades should create trade-offs, not always-dominant purchase paths. Document how hqItems.js and upgrades.js data shapes flow through the purchase pipeline.",
          "author": "Gameplay"
        }
      ]
    },
    {
      "title": "UI System & Visual Language",
      "purpose": "Document design-system primitives in src/ui/ and src/ui/shared/: GlitchButton (primary brutalist button), HUD (persistent top-bar overlay), EventModal (full-screen narrative event modal), ToastOverlay (temporary notification system), CrashHandler (error boundary), BandHQ (band management interface), DebugLogViewer (development debugging panel), SettingsPanel, VolumeSlider, and shared StatBox/ProgressBar components. Tie implementation to src/index.css tokens (--toxic-green #00FF41, --void-black #0A0A0A, --blood-red #CC0000, --ash-gray #3A3A3A, --warning-yellow #FFCC00), typography variables (--font-display for Metal Mania, --font-ui for Courier New monospace), CRT toggle behavior, and Tailwind v4 utility patterns from docs/TAILWIND_V4_PATTERNS.md.",
      "parent": "Overview",
      "page_notes": [
        {
          "content": "Explicitly enforce no hardcoded colors in components; reference CSS variable tokens from the theme. Use Tailwind v4 syntax bg-(--void-black) not v3 bracket syntax bg-[var(--void-black)]. Aesthetic is brutalist — uppercase buttons, boxy layouts, CRT overlay when settings.crtEnabled, glitch effects on hover/critical states.",
          "author": "Quality"
        },
        {
          "content": "Document CRT overlay behavior controlled by settings.crtEnabled and where that setting is read. Add explicit spacing/layout conventions used in panels and HUD to keep brutalist composition consistent.",
          "author": "Quality"
        }
      ]
    },
    {
      "title": "Data & Content",
      "purpose": "Explain content data contracts across src/data/events/* (band.js, financial.js, gig.js, special.js, transport.js), src/data/venues.js (~45 German venues with id, name, city, region, type, capacity, basePay, difficulty, prestige fields), src/data/songs.js (setlist tracks with bpm, difficulty, intensity, notePattern, crowdAppeal, staminaDrain), src/data/characters.js (3 default band members: Matze, Marius, Lars with stats/traits), src/data/chatter.js (social media templates), src/data/upgrades.js (VAN|GEAR|MERCH|PROMO categories), and src/data/hqItems.js: unique ID requirements, shape expectations, duplicate validation in events index, and runtime consumers.",
      "parent": "Overview",
      "page_notes": [
        {
          "content": "Cover event category files under src/data/events/ and how duplicate ID validation in the index aggregator protects runtime behavior. Add contributor checklist for new songs/events: ID uniqueness, required fields, and playtest/test expectations.",
          "author": "Quality"
        },
        {
          "content": "Note that src/data/songs.js is excluded from ESLint (configured in eslint.config.js ignores) due to its large size and generated-data nature. Song rhythm data lives separately in src/assets/rhythm_songs.json which contains MIDI note track definitions, BPM, and lane assignments consumed by rhythmUtils.js for note spawning. The chatter.js file provides social media post templates organized by category (praise, complaint, viral, meme) used by socialEngine.js and rendered through ChatterOverlay.jsx. Document the data contract between venues.js venue definitions and mapGenerator.js: venues must have unique IDs, valid region assignments from the REGIONS enum, and numeric capacity/basePay/difficulty/prestige fields within defined ranges.",
          "author": "Architecture"
        }
      ]
    },
    {
      "title": "Code Entity Map",
      "purpose": "Create a symbol index with exact file/function anchors for rapid onboarding: GameStateProvider/useGameState (GameState.jsx), ActionTypes/gameReducer branches (gameReducer.js), createChangeSceneAction (actionCreators.js), useRhythmGameLogic coordinator + 5 sub-hooks (rhythmGame/), useTravelLogic transitions, usePurchaseLogic predicates, calculateGigFinancials/calculateTravelExpenses (economyEngine.js), checkEvent/resolveChoice (eventEngine.js), applyEventDelta (gameStateUtils.js), AudioManager singleton (AudioManager.js), setupAudio/ensureAudioContext (audio/setup.js), generateMap (mapGenerator.js), and stage managers NoteManager/LaneManager/CrowdManager/EffectManager (components/stage/).",
      "parent": "Overview",
      "page_notes": [
        {
          "content": "Keep the map concise and link each symbol to one primary source file to reduce navigation friction. Include quick links for the most commonly edited files to accelerate triage during bugfix work.",
          "author": "Architecture"
        }
      ]
    },
    {
      "title": "Error Handling & Resilience",
      "purpose": "Document the error handling subsystem spanning src/utils/errorHandler.js (GameError, StateError, AudioError typed errors plus safeStorageOperation wrapper and toast dispatch), src/ui/CrashHandler.jsx (React error boundary for graceful crash recovery), and src/utils/logger.js (debug logging with level/category filtering). Explain how errors propagate from utility functions through hooks to UI toast notifications, how the error boundary prevents white-screen crashes, and how safeStorageOperation wraps localStorage access to handle quota/permission failures.",
      "parent": "System Architecture",
      "page_notes": [
        {
          "content": "Map each error type (GameError, StateError, AudioError) to the subsystems that throw them and the expected catch/handling sites. Document how CrashHandler.jsx renders fallback UI and whether it supports recovery actions or requires full reload.",
          "author": "Architecture"
        }
      ]
    },
    {
      "title": "Security & Threat Model",
      "purpose": "Map risks from neurotoxic-game-threat-model.md and security_best_practices_report.md to code-level controls: AudioContext autoplay restrictions handled by ensureAudioContext() flows, localStorage tampering exposure with exception-safe access via safeStorageOperation and validation/repair checks in loadGame() (src/context/GameState.jsx) plus saveValidator.js schema checks, reducer-safe defaults for malformed data, and scene-level fail-safe behavior to prevent hard crashes during startup/load/resume paths.",
      "parent": "Overview",
      "page_notes": [
        {
          "content": "Classify risks by severity and map each mitigation to specific functions/files where controls are implemented. Note expected behavior when tampered saves produce out-of-range values (clamp, reject, or reset strategy). Reference tests/security/ for save validation and unlock validation test suites.",
          "author": "Quality"
        }
      ]
    },
    {
      "title": "Development & Testing",
      "purpose": "Document the QA pipeline from package.json scripts and CI expectations: eslint checks (npm run lint via eslint.config.js flat config), node:test + tsx suites (npm run test with 49 test files in tests/), production build verification (npm run build), Playwright e2e flows in e2e/, and module-level test authoring patterns for hooks/utils. Reference tests/goldenPath.test.js as the critical path integration test covering menu -> overworld -> pregig -> gig -> postgig flow.",
      "parent": "Overview",
      "page_notes": [
        {
          "content": "Include node:test + tsx execution details: 'node --test --import tsx --experimental-test-module-mocks'. Mention specialized test categories: tests/security/ for save validation, tests/performance/ for context stability. Add guidance for when to run e2e tests vs unit tests and which changes mandate build verification.",
          "author": "Quality"
        }
      ]
    },
    {
      "title": "Project Configuration",
      "purpose": "Detail configuration surfaces and their responsibilities: package.json scripts/deps (type: module, engines: node >=22.3.0), vite.config.js base/react plugin behavior, eslint.config.js flat config (eslint:recommended + react + react-hooks + prettier, ignores dist/ and src/data/songs.js), .prettierrc (single quotes, no semicolons, 2-space indent, no trailing commas, arrow parens: avoid), biome.json style settings, postcss.config.js + tailwind.config.js integration, playwright.config.js e2e harness, .jscpd.json duplication detection, jsconfig.json (ESNext module, ES2022 target, react-jsx), and .nvmrc Node.js version pinning.",
      "parent": "Development & Testing",
      "page_notes": [
        {
          "content": "Mention production audio constraints (HTTPS/mixed-content considerations) and CI expectations from .github/workflows/ (deploy.yml deploys to GitHub Pages, super-linter.yml runs ESLint on PRs, lint-fix-preview.yml auto-fixes formatting). Document which config files are authoritative when settings overlap (eslint.config.js vs biome.json vs .prettierrc).",
          "author": "Quality"
        }
      ]
    },
    {
      "title": "Development Workflow",
      "purpose": "Describe contributor workflow with concrete checkpoints: npm install, npm run dev at localhost:5173, implement change in scoped module, run npm run lint + npm run test + npm run build, verify docs updates (including AGENTS.md when rules change), and craft Conventional Commit messages (feat:/fix:/docs:/test:/refactor:) that mention impacted subsystems/functions.",
      "parent": "Overview",
      "page_notes": [
        {
          "content": "Add a concise pre-PR checklist that mirrors AGENTS.md requirements and references docs/CODING_STANDARDS.md. Include release-readiness checks for documentation freshness in docs/ and AGENTS.md when architecture changes.",
          "author": "Quality"
        }
      ]
    },
    {
      "title": "Gig Playback & Audio Fallback Chains",
      "purpose": "Document gig audio execution runtime flow across src/hooks/rhythmGame/useRhythmGameAudio.js, src/utils/audioPlaybackUtils.js, src/utils/audioSelectionUtils.js, src/utils/audio/playback.js, src/utils/audio/procedural.js, and src/utils/AudioManager.js: the four playback fallback chains (song excerpt -> WebAudio buffer fallback -> generated backing -> silent safety mode), trigger conditions for each branch, handoff points between scene logic and low-level playback control, and mixer/synth defaults from audio/setup.js.",
      "parent": "Audio System Architecture",
      "page_notes": [
        {
          "content": "Gig notes parsing and playback must resolve excerpt windows via `resolveSongPlaybackWindow`. `excerptEndMs - excerptStartMs` is used to calculate `excerptDurationMs`, which is then passed as `durationMs`. Callers are responsible for providing these values; there is no synthetic default excerpt cap when metadata is absent.",
          "author": "Architecture"
        },
        {
          "content": "Capture exact branch order and guard conditions used at gig start, including when parsed chart notes exist but audio bootstrap fails, and when procedural note generation (audio/procedural.js) is invoked as a resilience path.",
          "author": "Architecture"
        },
        {
          "content": "List lifecycle boundaries: ensureAudioContext() unlock constraints, AudioManager singleton ownership, start/stop cleanup responsibilities, and failure telemetry paths (warnings/errors) to prevent stuck playback state.",
          "author": "Architecture"
        }
      ]
    },
    {
      "title": "Synchronization & Scaling Formulas",
      "purpose": "Document implementation-level formulas that tie rhythm timing, render sync, simulation, and balancing together across src/hooks/rhythmGame/ sub-hooks, src/components/PixiStageController.js, src/components/stage/ managers, src/utils/rhythmUtils.js, src/utils/simulationUtils.js, src/utils/economyEngine.js, and src/utils/gigStats.js, including the dual mutable ref model (gameStateRef vs statsRef), note positioning math, hit/miss windows, visual hit feedback timing, and daily/performance modifier calculations.",
      "parent": "Core Subsystems Overview",
      "page_notes": [
        {
          "content": "Describe gameStateRef vs statsRef responsibilities and why mutable refs are used for frame-loop synchronization without forcing React rerenders in the Pixi update cycle driven by PixiStageController ticker.",
          "author": "Architecture"
        },
        {
          "content": "Write the note positioning and hit-detection equations as explicit formulas (spawn lead-in, travel distance, hit window, miss window) and map each term to runtime variables in rhythmUtils.js.",
          "author": "Architecture"
        },
        {
          "content": "Consolidate concrete balancing formulas for daily updates (simulationUtils.js), resource flow (economyEngine.js), and gig performance modifiers (money/fuel/harmony/followers/fame multipliers via gigStats.js) so contributors can reason about economy changes without scanning multiple utilities.",
          "author": "Gameplay"
        }
      ]
    },
    {
      "title": "Social Engine & Procedural Assets",
      "purpose": "Document src/utils/socialEngine.js mechanics: platform multiplier tables, virality scoring formula, integration with GameStateProvider via dispatched ActionTypes for followers/fame updates, and social post rendering via src/components/ChatterOverlay.jsx using templates from src/data/chatter.js. Also document src/utils/imageGen.js integration with Pollinations.ai for procedural images: prompt construction from IMG_PROMPTS categories, network request lifecycle, in-memory caching strategy, fallback behavior on fetch failure or offline state, and where generated assets are consumed by scene/UI components.",
      "parent": "Core Subsystems Overview",
      "page_notes": [
        {
          "content": "Explain virality score calculation and risk/reward of post types. Detail how results feed into simulationUtils/economyEngine resource flow. Document caching/fallback strategy for imageGen and offline resilience given the no-backend architecture constraint.",
          "author": "Architecture"
        }
      ]
    },
    {
      "title": "Tutorial & Unlock Systems",
      "purpose": "Document the onboarding and progression systems: src/components/TutorialManager.jsx provides step-by-step onboarding tooltips guided by player.tutorialStep state, showing contextual help during first travel, first gig preparation, and first rhythm performance. src/utils/unlockManager.js tracks achievement/unlock milestones based on game progression (venues visited, gigs completed, fame thresholds), feeding into UI unlock indicators and gating access to higher-tier venues via venue requirements fields in src/data/venues.js.",
      "parent": "Overview",
      "page_notes": [
        {
          "content": "Document how tutorialStep advances through the reducer and which scenes consume it to display contextual guidance. Explain how unlockManager interacts with venue requirements to gate content progression.",
          "author": "Architecture"
        }
      ]
    },
    {
      "title": "CI/CD & Automation",
      "purpose": "Document the three GitHub Actions workflows in .github/workflows/: deploy.yml (builds production bundle via npm run build and deploys dist/ to GitHub Pages on push to main, using actions/upload-pages-artifact and actions/deploy-pages), super-linter.yml (runs ESLint via npm run lint on pull requests and pushes to main, posts inline annotations on PR diffs for violations), and lint-fix-preview.yml (runs Prettier + ESLint auto-fix on PRs and creates a preview comment showing proposed formatting changes). Also cover the agent instruction files in .github/agents/ (game_improver.agent.md, repo-setup.agent.md) that guide AI code assistants working in the repository.",
      "parent": "Development & Testing",
      "page_notes": [
        {
          "content": "Document deploy.yml pipeline stages: checkout, Node.js 22 setup (matching .nvmrc), npm ci (clean install from lockfile), npm run build (Vite production build), upload dist/ artifact, deploy to GitHub Pages. The workflow triggers on push to main only and uses the pages environment with GITHUB_TOKEN permissions. Explain how the base URL in vite.config.js must match the GitHub Pages deployment path for correct asset loading. Note that there is no staging environment — main branch deploys directly to production.",
          "author": "Quality"
        },
        {
          "content": "Document the Conventional Commits standard enforced by contributor workflow: feat: (new features, triggers minor version), fix: (bug fixes, triggers patch), docs: (documentation only), test: (test additions/changes), refactor: (code restructuring, no behavior change), chore: (maintenance, dependencies, CI). Commit messages should reference impacted subsystems (e.g., 'fix(audio): prevent context leak on gig end'). The lint-fix-preview workflow supports this by ensuring code style is consistent before merge, reducing noise in diffs and commit history.",
          "author": "Quality"
        }
      ]
    }
  ]
}
